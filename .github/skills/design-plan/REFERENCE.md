# design-plan スキル - リファレンス

このドキュメントには、design-plan スキルの補足情報を記載しています。

## 設計計画の目的

1. **実装の方向性を明確化**: テストや実装を始める前に要件を整理
2. **TDDの効率向上**: 設計仕様を元にテストケースを網羅的に作成可能
3. **ドキュメントの充実**: 実装と同時に設計ドキュメントが蓄積される
4. **レビューの容易化**: 設計レビュー → 実装レビューと段階的に確認可能
5. **補助ツールとの連携**: 各種ツールで設計を可視化・検証可能

## 設計計画の原則

1. **開発タイプに応じた設計**: CLI、API、画面、モバイル、インフラそれぞれに適した設計
2. **補助ツールの活用**: 業界標準のツールを使用して設計を可視化・検証
3. **テスタビリティ重視**: TDD実装を前提とした設計
4. **段階的な詳細化**: 初期は概要、必要に応じて詳細化
5. **プロジェクト固有のカスタマイズ**: 基本構造を提供し、各プロジェクトで調整可能

## 設計フェーズの実施手順

### 1. 要件の理解と分析

- Issue内容の確認
- 開発タイプの特定（CLI / API / 画面 / モバイル / インフラ）
- ステークホルダーの期待値確認

### 2. 設計ドキュメントの作成

- 該当する開発タイプのガイドを参照
- `docs/design/` 配下にドキュメントを作成
- 必要に応じて複数の開発タイプを組み合わせ

### 3. 補助ツールの設定

- OpenAPI仕様ファイルの作成（API開発の場合）
- Storybookのセットアップ（画面開発の場合）
- Terraformファイルの作成（インフラ構築の場合）
- その他、プロジェクトに応じた補助ツールの導入

### 4. 設計レビュー

- 補助ツールで設計を可視化
  - Swagger UIでAPIを確認
  - Storybookでコンポーネントを確認
  - `terraform plan`でインフラ変更を確認
- ステークホルダーとのレビュー
- フィードバックの反映

### 5. TDD実装への移行

- 設計ドキュメントを元にtest-driven-developmentスキルを実行
- Red-Green-Refactorサイクルで実装
- 設計と実装の乖離があれば設計ドキュメントを更新

## 設計ドキュメントの詳細な配置構造

### ディレクトリ構造

```
docs/
└── design/
    ├── README.md                           # 設計ドキュメント全体の概要
    ├── cli-specification.md                # CLI仕様（該当する場合）
    ├── api-specification.md                # API仕様（該当する場合）
    ├── openapi.yaml                        # OpenAPI仕様ファイル（API開発の場合）
    ├── ui-specification.md                 # UI/UX仕様（画面開発の場合）
    ├── mobile-specification.md             # モバイルUI仕様（モバイル開発の場合）
    ├── infrastructure-specification.md     # インフラ仕様（インフラ構築の場合）
    ├── storybook-setup.md                  # Storybookセットアップ（画面開発の場合）
    ├── architecture_diagram.py             # アーキテクチャ図生成スクリプト（インフラの場合）
    └── terraform/                          # Terraformファイル（インフラの場合）
        ├── main.tf
        ├── variables.tf
        └── outputs.tf
```

## 設計品質チェックポイント

設計ドキュメント作成後、以下の項目をチェックして品質を確保してください。

| 項目               | チェック内容                             |
| ------------------ | ---------------------------------------- |
| **完全性**         | すべての機能・要件が設計に含まれているか |
| **明確性**         | 曖昧さがなく、実装者が理解できるか       |
| **テスタビリティ** | テストケースを導出できる設計か           |
| **一貫性**         | 命名規則、スタイルが統一されているか     |
| **実現可能性**     | 技術的に実装可能な設計か                 |
| **拡張性**         | 将来の変更に対応しやすい設計か           |
| **セキュリティ**   | セキュリティリスクが考慮されているか     |
| **パフォーマンス** | パフォーマンス要件を満たせる設計か       |

### 開発タイプ別チェックポイント

#### CLI開発

- [ ] コマンド名は直感的で覚えやすいか
- [ ] 必須引数と任意引数が明確に区別されているか
- [ ] オプションの短縮形と長縮形が提供されているか
- [ ] --help と --version オプションが実装されているか
- [ ] エラーメッセージが明確で実行可能なアドバイスを含むか
- [ ] 終了コードが適切に設計されているか
- [ ] UNIX哲学（一つのことをうまくやる）に従っているか

#### API開発

- [ ] すべてのエンドポイントが文書化されているか
- [ ] リクエスト/レスポンススキーマが明確か
- [ ] エラーレスポンスが一貫した形式か
- [ ] 認証・認可の仕組みが明確か
- [ ] ページネーションの設計が適切か
- [ ] バージョニング戦略が定義されているか
- [ ] レート制限が考慮されているか
- [ ] HTTPステータスコードが適切に使用されているか

#### 画面開発

- [ ] コンポーネントが適切に分割されているか
- [ ] Props の型定義が明確か
- [ ] 状態管理の責任が明確か
- [ ] レスポンシブデザインが考慮されているか
- [ ] アクセシビリティ対応がされているか
- [ ] パフォーマンスが最適化されているか
- [ ] エラー状態が適切に処理されているか
- [ ] ローディング状態が表示されるか

#### モバイル開発

- [ ] 画面遷移が明確に定義されているか
- [ ] 各画面のレイアウトが仕様化されているか
- [ ] ジェスチャー操作が適切に設計されているか
- [ ] iOS/Android の差異が考慮されているか
- [ ] パフォーマンス要件が定義されているか
- [ ] オフライン動作が考慮されているか
- [ ] プッシュ通知の仕様が定義されているか

#### インフラ構築

- [ ] アーキテクチャ図が作成されているか
- [ ] リソース構成が明確に定義されているか
- [ ] ネットワーク設計（VPC、サブネット）が適切か
- [ ] セキュリティグループが最小権限の原則に従っているか
- [ ] IAMロールとポリシーが適切に設計されているか
- [ ] 暗号化が適切に実装されているか
- [ ] Multi-AZ構成で高可用性が確保されているか
- [ ] Auto Scalingが適切に設定されているか
- [ ] バックアップ戦略が定義されているか
- [ ] 監視・アラート設定が適切か
- [ ] コスト見積もりが行われているか

## 他のスキルとの連携

### test-driven-development スキルとの連携

design-plan スキルと test-driven-development スキルは、設計から実装までのシームレスなワークフローを提供します。

**ワークフロー**:

```
design-plan
  ↓ 設計ドキュメント作成
  ↓
[設計レビュー]
  ↓
test-driven-development
  ↓ Red: 設計仕様から失敗するテストを書く
  ↓ Green: 設計に従って実装
  ↓ Refactor: 設計原則に基づいてリファクタリング
  ↓
実装完了
```

**連携のポイント**:

- **設計 → テスト**: 設計ドキュメントからテストケースを抽出
- **Redフェーズ**: 設計仕様を元に期待する振る舞いをテストで表現
- **Greenフェーズ**: 設計に従って最小限の実装
- **Refactorフェーズ**: 設計原則（SOLID、DRYなど）に基づいて改善

### github-issue スキルとの連携

Issue の要件を設計ドキュメントに落とし込むプロセス。

**連携のポイント**:

- **Issue → 設計**: Issueの要件定義を設計ドキュメントに変換
- **受け入れ基準の明確化**: Issueの受け入れ基準を設計で具体化
- **設計完了**: 設計ドキュメントをIssueコメントで共有してレビュー依頼

### pull-request スキルとの連携

設計の変更を含むPRを作成する際の連携。

**連携のポイント**:

- **設計の変更**: PRで設計ドキュメントの変更も含める
- **レビュー観点**: 設計と実装の整合性を確認
- **Changes セクション**: 設計ドキュメントの変更内容を明記

### code-review スキルとの連携

設計レビューと実装レビューの両方を実施。

**連携のポイント**:

- **2段階レビュー**:
  1. 設計レビュー（設計ドキュメント）
  2. 実装レビュー（コード）
- **レビュアーの負担軽減**: 設計で方向性を確認してから実装
- **早期フィードバック**: 実装前に設計の問題を発見

### self-review スキルとの連携

実装完了後のセルフレビューで、設計との整合性を確認。

**連携のポイント**:

- **設計との乖離チェック**: 実装が設計通りか確認
- **設計ドキュメントの更新**: 実装で判明した設計の不備を修正
- **学習**: 設計と実装のギャップから学ぶ

## 補助ツールの選定基準

プロジェクトに適した補助ツールを選定する際の基準です。

### 1. オープンソース

- **優先**: 可能な限りOSSツールを優先
- **理由**: コスト削減、コミュニティサポート、透明性
- **例外**: 商用ツールが圧倒的に優れている場合（Figmaなど）

### 2. 業界標準

- **優先**: 広く採用されている実績のあるツール
- **理由**: ドキュメントが豊富、採用候補者が知っている可能性が高い
- **確認方法**: GitHub Stars、Stack Overflow質問数、求人での言及

### 3. ドキュメント品質

- **必須**: 十分なドキュメントとコミュニティサポート
- **確認項目**:
  - 公式ドキュメントの充実度
  - チュートリアルの有無
  - Stack Overflowなどでの活発な質疑応答
  - GitHub Issuesでのメンテナーの対応

### 4. CI/CD統合

- **推奨**: 自動化とテストに組み込みやすいツール
- **確認項目**:
  - コマンドラインインターフェース（CLI）の有無
  - CI/CDプラットフォーム（GitHub Actions、GitLab CI）との統合例
  - Docker イメージの提供

### 5. プロジェクト適合性

- **必須**: チームのスキルセットと要件に合致
- **確認項目**:
  - チームの既存知識
  - プロジェクトの技術スタック
  - パフォーマンス要件
  - セキュリティ要件

### 開発タイプ別の推奨ツール

#### API開発

**基本ツール**: Swagger UI / OpenAPI Specification

- **理由**: 業界標準、広く採用、豊富なエコシステム
- **代替案**: API Blueprint（マークダウン形式を好む場合）
- **補完ツール**: Postman（テスト）、Stoplight Studio（ビジュアルエディタ）

#### 画面開発

**基本ツール**: Storybook

- **理由**: React/Vue/Angularなど主要フレームワークをサポート、コンポーネント駆動開発に最適
- **代替案**: Histoire（Vite専用、軽量）
- **補完ツール**: Chromatic（ビジュアルレグレッションテスト）

#### インフラ構築

**基本ツール**: Terraform / OpenTofu

- **理由**: マルチクラウド対応、広く採用、豊富なプロバイダー
- **代替案**:
  - AWS CloudFormation / CDK（AWS専用）
  - Pulumi（プログラミング言語で記述したい場合）
- **補完ツール**: Checkov（セキュリティスキャン）、Infracost（コスト見積もり）

## カスタマイズとプロジェクト固有の調整

このスキルは基本的な設計ドキュメント構造と推奨補助ツールを提供します。各プロジェクトで以下をカスタマイズしてください。

### 1. ドキュメント構造のカスタマイズ

**デフォルト構造**:

```
docs/design/
├── README.md
├── [type]-specification.md
└── [supplementary files]
```

**プロジェクト固有の調整例**:

```
docs/
├── architecture/           # アーキテクチャドキュメント
│   └── design/
├── api/                    # API仕様
│   ├── openapi.yaml
│   └── postman/
└── ui/                     # UI/UX仕様
    ├── storybook/
    └── figma-links.md
```

### 2. 補助ツールの選択

**プロジェクトの特性に応じて選択**:

- **スタートアップ**: 無料ツール優先（Swagger UI、Storybook、Terraform）
- **エンタープライズ**: 商用ツールも検討（Stoplight、Figma、Chromatic）
- **既存ツールチェーン**: 既に導入済みのツールと統合

### 3. テンプレートの拡張

**プロジェクト固有の要件を追加**:

- 会社独自のセキュリティ要件
- 業界特有の規制（金融、医療など）
- 社内のコーディング規約
- ブランドガイドライン

**例**: API仕様にセキュリティ要件セクションを追加

```markdown
## セキュリティ要件

### OWASP API Security Top 10 対策

- [ ] API1: Broken Object Level Authorization
- [ ] API2: Broken Authentication
- [ ] API3: Broken Object Property Level Authorization
      ...
```

### 4. ワークフローの調整

**デフォルトワークフロー**:

```
設計 → レビュー → TDD実装
```

**プロジェクト固有の調整例**:

```
要件定義 → 設計 → セキュリティレビュー → 設計承認 → TDD実装 → コードレビュー → QA → リリース
```

### 5. ツールチェーン統合

**既存の開発環境との統合**:

- CIパイプラインに設計ドキュメントの検証を追加
- 社内ドキュメントシステムとの連携
- デザインツール（Figma）とのリンク
- プロジェクト管理ツール（Jira、Asana）との連携

## 注意事項

### 1. 過度な設計を避ける

**問題**:

- 設計に時間をかけすぎて実装が遅れる
- 実装で使われない詳細まで設計する

**対策**:

- 必要十分な設計にとどめる
- 実装中に詳細化する（段階的詳細化）
- タイムボックスを設定（例: 設計に1-2日まで）

**良い例**:

- API: エンドポイント、リクエスト/レスポンススキーマ、認証方式
- 詳細な実装ロジックは TDD で決定

**悪い例**:

- すべてのエッジケースを事前に設計
- 実装レベルの詳細（変数名、ループの書き方など）まで設計

### 2. 設計と実装の同期

**問題**:

- 実装で設計を変更したが、ドキュメントが更新されない
- 設計ドキュメントと実装が乖離する

**対策**:

- 実装で設計変更があればドキュメントを即座に更新
- PRレビューで設計との整合性を確認
- 定期的に設計ドキュメントを見直す

**ベストプラクティス**:

- 設計ドキュメントをコードと同じリポジトリで管理
- 設計変更もPRに含める
- "設計が実装の真実"ではなく"実装が真実、設計はそれを反映"

### 3. 補助ツールの学習コスト

**問題**:

- 新しいツールの学習に時間がかかる
- チームメンバーのスキルレベルが異なる

**対策**:

- チームの習熟度に応じてツールを選択
- 簡単なツールから始める（例: Markdownドキュメント → Swagger UI → 高度なツール）
- ペアデザイン、ペアプログラミングで知識共有

**推奨アプローチ**:

1. 第1フェーズ: Markdownで設計ドキュメント作成
2. 第2フェーズ: Swagger UI / Storybook 導入
3. 第3フェーズ: Chromatic / Infracost など高度なツール導入

### 4. 設計レビューの重要性

**問題**:

- 設計レビューをスキップして実装開始
- 実装後に大きな設計ミスが発覚

**対策**:

- 実装前に必ず設計をレビュー
- ステークホルダー（PM、デザイナー、他の開発者）を巻き込む
- 補助ツール（Swagger UI、Storybook）で設計を可視化してレビュー

**レビューポイント**:

- 要件を満たしているか
- セキュリティリスクはないか
- パフォーマンス要件を満たせるか
- 拡張性は十分か

### 5. 複数開発タイプの組み合わせ

**注意**:

- 1つのプロジェクトで複数の開発タイプを組み合わせることが多い
- 例: APIサーバー（API開発） + Webフロントエンド（画面開発） + インフラ（インフラ構築）

**対策**:

- それぞれの開発タイプに対応する設計ドキュメントを作成
- 依存関係を明確にする（例: フロントエンドはAPIに依存）
- 統合的なアーキテクチャ図を作成

**ドキュメント構成例**:

```
docs/design/
├── README.md                       # 全体概要と各設計ドキュメントへのリンク
├── architecture-overview.md        # システム全体のアーキテクチャ
├── api-specification.md            # APIサーバーの設計
├── openapi.yaml
├── ui-specification.md             # Webフロントエンドの設計
├── storybook/
└── infrastructure-specification.md # インフラの設計
```

### 6. ドキュメントのメンテナンス

**問題**:

- 古い設計ドキュメントが残り続ける
- どれが最新版かわからない

**対策**:

- バージョン管理（Git）で履歴を追跡
- 古いドキュメントは削除またはアーカイブ
- ドキュメントに最終更新日を記載

**ベストプラクティス**:

```markdown
# API仕様

**最終更新**: 2024-01-15
**バージョン**: v1.2.0
**ステータス**: 現行版
```

## クイックスタート

開発タイプ別のクイックスタート例です。詳細は各 resources/ 配下のガイドを参照してください。

### API設計の例

```bash
# 1. OpenAPI仕様ファイルを作成
mkdir -p docs/design
touch docs/design/openapi.yaml

# 2. API仕様を記述（resources/api_design_desc.md 参照）

# 3. Swagger UIで確認
npx @stoplight/prism-cli mock docs/design/openapi.yaml
```

### 画面設計の例

```bash
# 1. UI仕様書を作成
touch docs/design/ui-specification.md

# 2. Storybookをセットアップ
npx storybook@latest init

# 3. Storybookを起動
npm run storybook
```

### インフラ設計の例

```bash
# 1. Terraformディレクトリを作成
mkdir -p docs/design/terraform

# 2. Terraform設定を記述（resources/infrastructure_design_desc.md 参照）

# 3. プラン確認
cd docs/design/terraform
terraform init
terraform plan
```

## よくある質問（FAQ）

### Q1: 設計にどのくらい時間をかけるべきですか？

**A**: プロジェクトの規模によりますが、一般的なガイドライン：

- **小規模機能**: 0.5〜1日
- **中規模機能**: 1〜2日
- **大規模機能**: 2〜3日

実装時間の10-20%を設計に充てるのが目安です。

### Q2: すべての開発で設計ドキュメントが必要ですか？

**A**: いいえ。以下の場合はスキップ可能：

- 簡単なバグ修正
- 既存コードのリファクタリング（動作変更なし）
- 実験的なプロトタイプ

新機能開発や大きな変更の場合は設計ドキュメントを作成することを推奨します。

### Q3: 設計ドキュメントと実装が乖離した場合、どちらを信頼すべきですか？

**A**: **実装が真実**です。

設計ドキュメントを実装に合わせて更新してください。ただし、実装が設計意図を満たしていない場合は、実装を修正することも検討してください。

### Q4: 補助ツールは必須ですか？

**A**: いいえ、必須ではありません。

プロジェクトの規模やチームの習熟度に応じて選択してください。小規模プロジェクトではMarkdownドキュメントだけでも十分です。

### Q5: 複数人で設計する場合のベストプラクティスは？

**A**:

- **ペアデザイン**: 2人で一緒に設計を作成
- **デザインレビュー**: 1人が設計を作成し、他のメンバーがレビュー
- **分担**: 各モジュールの設計を担当者に分担（全体統合レビューは必須）

いずれの場合も、最終的に全員でレビューすることが重要です。

## 関連リソース

### 公式ドキュメント

- [OpenAPI Specification](https://swagger.io/specification/)
- [Storybook Documentation](https://storybook.js.org/docs)
- [Terraform Documentation](https://www.terraform.io/docs)

### 参考書籍

- "Design It!: From Programmer to Software Architect" - Michael Keeling
- "The Design of Web APIs" - Arnaud Lauret
- "Atomic Design" - Brad Frost
- "Terraform: Up & Running" - Yevgeniy Brikman

### オンラインリソース

- [API Design Guide (Google)](https://cloud.google.com/apis/design)
- [RESTful API Design Best Practices](https://restfulapi.net/)
- [Component Driven Development](https://www.componentdriven.org/)
- [AWS Well-Architected Framework](https://aws.amazon.com/architecture/well-architected/)
